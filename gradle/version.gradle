import org.eclipse.jgit.api.Git
import org.eclipse.jgit.lib.Constants
import org.eclipse.jgit.lib.ObjectId
import org.eclipse.jgit.lib.ObjectReader
import org.eclipse.jgit.lib.PersonIdent
import org.eclipse.jgit.lib.Ref
import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.revwalk.RevCommit
import org.eclipse.jgit.storage.file.FileRepositoryBuilder

import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'org.eclipse.jgit:org.eclipse.jgit:5.13.+'
    }
}

class VersionExtension {
    static DateTimeFormatter formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME

    Project project
    boolean stripBranchPrefix = true
    List<String> customPrefixes = []
    boolean useDirty = false
    boolean parsedVersion = false
    String timestamp = '1970-01-01T00:00:00+00:00'
    String commitId = '0000000000000000000000000000000000000000'
    String abbrevId = '000000'
    String rawVersion = '0.0.0'
    boolean snapshot = true
    String classifiers = '-UNKNOWN'
    int incrementPositionIfSnapshot = 0
    Spec<VersionInformation> skipIncrement = Specs.satisfyNone()

    VersionExtension(Project project) {
        this.project = project
    }

    void calculateVersion() {
        if (parsedVersion) return
        parsedVersion = true
        try (Repository repository = new FileRepositoryBuilder()
                .readEnvironment()
                .findGitDir(project.projectDir)
                .setMustExist(true).build()) {
            boolean hasCommitId = false
            String branchName = null

            Ref head = repository.exactRef(Constants.HEAD)
            if (head != null && head.isSymbolic()) {
                branchName = Repository.shortenRefName(head.getTarget().getName())
            }

            // Find HEAD commit and extract ID and timestamp
            try (ObjectReader reader = repository.newObjectReader()) {
                final ObjectId headCommitId = repository.resolve(Constants.HEAD)
                final RevCommit headCommit = repository.parseCommit(headCommitId) // TODO throws

                final PersonIdent identity = headCommit.committerIdent
                final OffsetDateTime date = OffsetDateTime.ofInstant(identity.when.toInstant(),
                        identity.timeZone.toZoneId())

                timestamp = formatter.format(date)
                commitId = headCommit.name()
                abbrevId = reader.abbreviate(headCommitId).name()
                hasCommitId = true
            }

            final Git git = Git.wrap(repository)
            final String describe = git.describe().setTags(true).setLong(true).call()

            // By default, the classifier is set to the commit ID if available
            classifiers = hasCommitId ? "+${abbrevId ?: commitId}" : ''

            if (describe != null) {
                String descVer, descCount

                final int lastSep = describe.lastIndexOf('-')
                final String allExceptLast = describe.substring(0, lastSep)
                final int secondToLastSep = allExceptLast.lastIndexOf('-')
                descVer = allExceptLast.substring(0, secondToLastSep)
                descCount = allExceptLast.substring(secondToLastSep + 1)

                if (stripBranchPrefix) {
                    if (branchName != null && descVer.length() > branchName.length() + 1) {
                        String sep = descVer.charAt(branchName.length())
                        if (descVer.startsWith(branchName) && (sep == '/' || sep == '-')) {
                            descVer = descVer.substring(branchName.length() + 1)
                        }
                    }

                    for (String prefix : customPrefixes) {
                        if (descVer.length() > prefix.length() + 1) {
                            String sep = descVer.charAt(prefix.length())
                            if (descVer.startsWith(prefix) && (sep == '/' || sep == '-')) {
                                descVer = descVer.substring(prefix.length() + 1)
                                break
                            }
                        }
                    }
                }

                rawVersion = descVer.startsWith('v') ? descVer.substring(1) : descVer
                final int commitCount = Integer.parseInt(descCount)
                final boolean dirty = !git.status().call().clean

                if (commitCount == 0) {
                    snapshot = dirty
                    classifiers = ''
                } else if (dirty && useDirty) {
                    classifiers = '.dirty'
                }
            }

            if (snapshot) {
                if (classifiers != '-UNKNOWN' && rawVersion != '0.0.0' && incrementPositionIfSnapshot != 0
                        && !skipIncrement.isSatisfiedBy(new VersionInformation(rawVersion, snapshot, classifiers, timestamp, commitId))) {
                    String[] rawVersionSplit = rawVersion.split('[\\-+_]', 2)
                    String[] versionSplit = rawVersionSplit[0].split('\\.')
                    boolean changed
                    if (versionSplit.length >= Math.abs(incrementPositionIfSnapshot)) {
                        int i = incrementPositionIfSnapshot < 0
                                ? versionSplit.length + incrementPositionIfSnapshot
                                : incrementPositionIfSnapshot - 1
                        try {
                            versionSplit[i] = (Integer.parseInt(versionSplit[i]) + 1) as int

                            boolean hasExtra = rawVersionSplit.length > 1
                            if (hasExtra) {
                                rawVersion = String.join("${rawVersion.charAt(rawVersionSplit[0].length())}",
                                        [String.join('.', versionSplit), rawVersionSplit[1]])
                            } else {
                                rawVersion = String.join('.', versionSplit)
                            }
                        } catch (NumberFormatException ignored) {}
                    }
                }
                classifiers = '-SNAPSHOT' + classifiers
            }
        } catch (Exception e) {
            project.logger.warn("Exception while getting version info from Git: {}", e.toString())
        }
    }

    void setStripBranchPrefix(boolean stripBranchPrefix) {
        this.stripBranchPrefix = stripBranchPrefix
    }

    boolean getStripBranchPrefix() {
        return stripBranchPrefix
    }

    void setCustomPrefix(String customPrefix) {
        if (customPrefix?.empty) return
        if (customPrefix == null) this.customPrefixes.clear()
        this.customPrefixes += customPrefix
    }

    void customPrefix(String customPrefix) {
        if (customPrefix?.empty) return
        if (customPrefix != null) this.customPrefixes += customPrefix
    }

    String[] getCustomPrefixes() {
        return customPrefixes
    }

    void setUseDirty(boolean useDirty) {
        this.useDirty = useDirty
    }

    boolean getUseDirty() {
        return useDirty
    }

    /**
     * @param incrementPositionIfSnapshot the one-based position to increment, or {@code 0} to disable. Negative values 
     * are interpreted as positions starting from the end; {@code -1} would be the last number in the version, {@code -2}
     * would be the second-to-last position, and so on.
     */
    void incrementPositionIfSnapshot(int incrementPositionIfSnapshot) {
        this.setIncrementPositionIfSnapshot(incrementPositionIfSnapshot)
    }

    /**
     * @param incrementPositionIfSnapshot the one-based position to increment, or {@code 0} to disable. Negative values 
     * are interpreted as positions starting from the end; {@code -1} would be the last number in the version, {@code -2}
     * would be the second-to-last position, and so on.
     */
    void setIncrementPositionIfSnapshot(int incrementPositionIfSnapshot) {
        this.incrementPositionIfSnapshot = incrementPositionIfSnapshot
    }

    boolean getIncrementPositionIfSnapshot() {
        return incrementPositionIfSnapshot
    }

    void skipIncrementForClassifiers(List<String> classifiers) {
        skipIncrement { ver ->
            classifiers.any {ver.rawVersion.contains("-$it")}
        }
    }

    void skipIncrementForClassifiers(String... classifiers) {
        skipIncrementForClassifiers([classifiers].flatten().findAll { it != null })
    }

    void skipIncrement(Spec<VersionInformation> skipIncrement) {
        this.setSkipIncrement(skipIncrement)
    }

    void setSkipIncrement(Spec<VersionInformation> skipIncrement) {
        this.skipIncrement = skipIncrement
    }

    Spec<String> getSkipIncrement() {
        return skipIncrement
    }

    String getVersion() {
        calculateVersion()
        return this.rawVersion + this.classifiers
    }

    String getRawVersion() {
        calculateVersion()
        return this.rawVersion
    }

    String getSimpleVersion() {
        calculateVersion()
        return this.rawVersion + (this.snapshot ? '-SNAPSHOT' : '')
    }

    String getCommitTimestamp() {
        calculateVersion()
        return this.timestamp
    }

    String getAbbreviatedCommitId() {
        calculateVersion()
        return this.abbrevId
    }

    String getCommitId() {
        calculateVersion()
        return this.commitId
    }

    String getClassifiers() {
        calculateVersion()
        return this.classifiers
    }

    boolean isSnapshot() {
        calculateVersion()
        return this.snapshot
    }

    @groovy.transform.Immutable
    class VersionInformation {
        String rawVersion
        boolean snapshot
        /**
         * The classifiers of the version. This does not include the automatically prepended {@code -SNAPSHOT} classifier
         * when {@link #snapshot} is {@code true}.
         */
        String classifiers
        String commitTimestamp
        String commitId
    }
}

project.extensions.create("versions", VersionExtension, project)